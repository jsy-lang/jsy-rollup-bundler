import {parse as path_parse} from 'path'
import {rollup} from 'rollup'
import chokidar from 'chokidar'
import rpi_babel from 'rollup-plugin-babel'

export function jsy_plugin() ::
  const jsy_preset = @[] 'jsy/lean', @{} no_stage_3: true, modules: false
  return rpi_babel @:
    exclude: 'node_modules/**'
    presets: [ jsy_preset ]
    plugins: []
    babelrc: false
    highlightCode: false

export function bundle({source, opt, globalModules, plugins, format, amd}) ::
  if 'string' !== typeof source :: throw new TypeError @ `Expected string source parameter`
  if null == opt :: throw new TypeError @ `Expected valid "opt" object parameter`
  opt = Object.assign @ {}, opt
  if null == globalModules :: globalModules = opt.globalModules || {}
  if null == plugins :: plugins = opt.plugins || []
  if null == opt.suffix :: opt.suffix = opt.production ? '.min' : ''
  if null == opt.outdir :: opt.outdir = './dist/public'
  if null == opt.source :: opt.source = path_parse @ source

  const input = @{} input: source, plugins,
    external: module => !! globalModules[module]

  if ! format ::
    format = amd ? 'amd' : 'iife'

  const output = @{}
    format
    name: opt.source.name
    file: `${opt.outdir}/${opt.source.name}${opt.suffix}.js`
    sourcemap: opt.sourcemap
    globals: module => globalModules[module]

  if amd && 'amd' === format :: output.amd = amd

  return asRollupBuildClosure @:
    input, output, opt

export function asRollupBuildClosure({input, output, opt}) ::
  let bundle
  return async function () ::
    const log_msg = `rollup bundle "${opt.source.name}" (@${Date.now().toString(36)})`
    console.log @ `Building ${log_msg}`
    console.time @ `Built ${log_msg}`
    try ::
      input.cache = bundle
      console.time @ `Compiled ${log_msg}`
      bundle = await rollup(input)
      console.timeEnd @ `Compiled ${log_msg}`
      await bundle.write(output)
    finally ::
      console.timeEnd @ `Built ${log_msg}`


export function buildAll(buildList) ::
  return Promise.all @ buildList.map @
    builder => builder()


export function watchAndBuild() ::
  let watchers = []
  const self = @{} rebuildOn, buildOnce, restartOn
  return self


  function restartOn(watch_glob) ::
    watchers.push @ chokidar
      .watch @ watch_glob, @{}
        ignoreInitial: true
        ignorePermissionErrors: true

      .on @ 'change', path => ::
        console.log @ `Setup changed; shutting down watchers ("${path}")`
        const l_watchers = watchers
        watchers = null
        for const each of l_watchers ::
          each.close()

    return self

  function buildOnce(buildOnce, watch_glob) ::
    if Array.isArray(buildOnce) ::
      buildOnce = buildAll.bind @ null, buildOnce

    if 'function' !== typeof buildOnce ::
      throw new TypeError @ `Expected buildOnce to be a function or array`

    if watch_glob :: restartOn @ watch_glob

    buildOnce()
    return self

  function rebuildOn(rebuild, watch_glob) ::
    let inprogress = false
    if Array.isArray(rebuild) ::
      rebuild = buildAll.bind @ null, rebuild

    if 'function' !== typeof rebuild ::
      throw new TypeError @ `Expected rebuild to be a function or array`

    // invoke initial build
    rebuild()

    watchers.push @ chokidar
      .watch @ watch_glob, @{}
        ignoreInitial: true
        ignorePermissionErrors: true

      .on @ 'change', _debounce

    return self

    function _debounce(path) ::
      // debounce rapid updates
      if false === inprogress ::
        inprogress = true
        setTimeout @
          () => ::
            inprogress = false
            rebuild()
          50
        .unref()
      return self

