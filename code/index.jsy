import {parse as path_parse} from 'path'
import {rollup} from 'rollup'
import chokidar from 'chokidar'
import rpi_babel from 'rollup-plugin-babel'

export function jsy_plugin(kwargs) ::
  const jsy_preset = @[] 'jsy/lean', @{} no_stage_3: true, modules: false
  const presets = [jsy_preset].concat @ kwargs.presets || []
  //const plugins = [].concat @ kwargs.plugins || []

  kwargs = Object.assign @
    @{} exclude: 'node_modules/**'
        babelrc: false, highlightCode: false
    kwargs
    @{} presets, plugins

  return rpi_babel(kwargs)

export function bundle({source, opt, globalModules, externals, plugins, format, amd}) ::
  if 'string' !== typeof source :: throw new TypeError @ `Expected string source parameter`
  if null == opt :: throw new TypeError @ `Expected valid "opt" object parameter`
  opt = Object.create @ opt // Don't modify the underlying object
  if null == globalModules :: globalModules = opt.globalModules || {}
  if null == externals :: externals = opt.externals || []
  if null == plugins :: plugins = opt.plugins || []
  if null == format :: format = opt.format || 'iife'
  if null == opt.suffix :: opt.suffix = opt.production ? '.min' : ''
  if null == opt.outdir :: opt.outdir = './dist/public'
  if null == opt.source :: opt.source = path_parse @ source

  externals = new Set @ externals
  const input = @{} input: source, plugins,
    external: module => !! globalModules[module] || externals.has(module)

  if amd :: format = 'amd'

  const output = @{}
    format
    name: opt.source.name
    file: `${opt.outdir}/${opt.source.name}${opt.suffix}.js`
    sourcemap: opt.sourcemap
    globals: module => globalModules[module]

  if amd :: output.amd = amd

  return asRollupBuildClosure @:
    input, output, opt

export function asRollupBuildClosure({input, output, opt}) ::
  let bundle
  return async function () ::
    const log_msg = `rollup bundle "${opt.source.name}" (@${Date.now().toString(36)})`
    console.log @ `Building ${log_msg}`
    console.time @ `Built ${log_msg}`
    try ::
      input.cache = bundle
      console.time @ `Compiled ${log_msg}`
      bundle = await rollup(input)
      console.timeEnd @ `Compiled ${log_msg}`
      await bundle.write(output)

    catch err ::
      const {code, loc, frame} = err
      const lines = @[]
        ''
        ''
        `${err.message} (${code})`
        `  in "${loc.file}" at ${loc.line}:${loc.column}"`
        ''
        frame
        ''
        ''

      console.error @ lines.join('\n')

    finally ::
      console.timeEnd @ `Built ${log_msg}`


export function buildAll(buildList) ::
  return Promise.all @ buildList.map @
    builder => builder()


export function watchAndBuild() ::
  let watchers = []
  const self = @{} rebuildOn, buildOnce, restartOn
  return self


  function restartOn(watch_glob) ::
    watchers.push @ chokidar
      .watch @ watch_glob, @{}
        ignoreInitial: true
        ignorePermissionErrors: true

      .on @ 'change', path => ::
        console.log @ `Setup changed; shutting down watchers ("${path}")`
        const l_watchers = watchers
        watchers = null
        for const each of l_watchers ::
          each.close()

    return self

  function buildOnce(buildOnce, watch_glob) ::
    if Array.isArray(buildOnce) ::
      buildOnce = buildAll.bind @ null, buildOnce

    if 'function' !== typeof buildOnce ::
      throw new TypeError @ `Expected buildOnce to be a function or array`

    if watch_glob :: restartOn @ watch_glob

    buildOnce()
    return self

  function rebuildOn(rebuild, watch_glob) ::
    let inprogress = false
    if Array.isArray(rebuild) ::
      rebuild = buildAll.bind @ null, rebuild

    if 'function' !== typeof rebuild ::
      throw new TypeError @ `Expected rebuild to be a function or array`

    // invoke initial build
    rebuild()

    watchers.push @ chokidar
      .watch @ watch_glob, @{}
        ignoreInitial: true
        ignorePermissionErrors: true

      .on @ 'change', _debounce

    return self

    function _debounce(path) ::
      // debounce rapid updates
      if false === inprogress ::
        inprogress = true
        setTimeout @
          () => ::
            inprogress = false
            rebuild()
          50
        .unref()
      return self

